<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-相机模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:43:16.096Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h1><h2 id="相机传感器型号与对应参数"><a href="#相机传感器型号与对应参数" class="headerlink" title="相机传感器型号与对应参数"></a>相机传感器型号与对应参数</h2><table>
<thead>
<tr>
<th>格式</th>
<th>宽度</th>
<th>长度</th>
<th>对角线</th>
<th>面积</th>
<th>焦距系数</th>
</tr>
</thead>
<tbody><tr>
<td>中画幅</td>
<td>33.0</td>
<td>44.0</td>
<td>55.0</td>
<td>1452</td>
<td>0.7</td>
</tr>
<tr>
<td>全画幅</td>
<td>24.0</td>
<td>36.0</td>
<td>43.4</td>
<td>864</td>
<td>1.0</td>
</tr>
<tr>
<td>Red Epic</td>
<td>14.6</td>
<td>27.7</td>
<td>31.3</td>
<td>404</td>
<td>1.3</td>
</tr>
<tr>
<td>Super 35mm</td>
<td>13.8</td>
<td>24.6</td>
<td>28.0</td>
<td>339</td>
<td>1.4</td>
</tr>
<tr>
<td>APS-C</td>
<td>15.6</td>
<td>23.5</td>
<td>28.3</td>
<td>368</td>
<td>1.5</td>
</tr>
<tr>
<td>1.5”</td>
<td>14.0</td>
<td>18.7</td>
<td>23.4</td>
<td>262</td>
<td>1.9</td>
</tr>
<tr>
<td>4/3</td>
<td>13.5</td>
<td>18.0</td>
<td>22.4</td>
<td>243</td>
<td>2.0</td>
</tr>
<tr>
<td>2/3”</td>
<td>6.6</td>
<td>8.8</td>
<td>11.0</td>
<td>58</td>
<td>4.0</td>
</tr>
<tr>
<td>1/1.7”</td>
<td>5.6</td>
<td>7.4</td>
<td>9.5</td>
<td>42</td>
<td>4.6</td>
</tr>
<tr>
<td>1/2”</td>
<td>4.8</td>
<td>6.4</td>
<td>8.0</td>
<td>31</td>
<td>5.4</td>
</tr>
<tr>
<td>1/2.5”</td>
<td>4.3</td>
<td>5.8</td>
<td>7.2</td>
<td>25</td>
<td>6.0</td>
</tr>
<tr>
<td>1/3”</td>
<td>3.6</td>
<td>4.8</td>
<td>6.0</td>
<td>17</td>
<td>7.2</td>
</tr>
</tbody></table>
<p>图像传感器感光区域的面积大小。这个尺寸直接决定了整个系统的物理放大率。如：1/3”、1/2”等。绝大多数模拟相机的传感器的长宽比例是4：3(H：V)，数字相机的长宽比例则包括多种：1：1，16：9，3：2 etc。注意相机尺寸的 1”=16mm≠25.4mm</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/" data-id="cklm1tp1e000kfwuc0hli6oc3" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c++与OOP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/c++%E4%B8%8EOOP/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:43:16.015Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C（拒绝goto）"><a href="#C（拒绝goto）" class="headerlink" title="C（拒绝goto）"></a>C（拒绝goto）</h1><h2 id="Struct-Enum-Union"><a href="#Struct-Enum-Union" class="headerlink" title="Struct,Enum,Union"></a>Struct,Enum,Union</h2><ul>
<li>结构体的初始化和声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">    int Code;</span><br><span class="line">    char Name[20];</span><br><span class="line">    char Sex;</span><br><span class="line">    int Age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student Stu;</span><br><span class="line">struct Student Stu[10];</span><br><span class="line">struct Student *pStru;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">    int Code;</span><br><span class="line">    char Name[20];</span><br><span class="line">    char Sex;</span><br><span class="line">    int Age;</span><br><span class="line">&#125;Stu,Stu[10],*pStu;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int Code;</span><br><span class="line">    char Name[20];</span><br><span class="line">    char Sex;</span><br><span class="line">    int Age;</span><br><span class="line">&#125;Student;</span><br><span class="line">Student Stu,Stu[10],*pStu;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。</p>
<ul>
<li>用结构储存串</li>
</ul>
<p>指针还是数组，一般情况下选择定长数组，如果使用指针，必须预先分配足够的空间</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>声明函数形式参数和返回值</p>
<h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>实际参数是具体的值，形式参数是变量</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数调用自己</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数具有唯一的返回值，且不能返回引用</p>
<h2 id="Pointer与动态内存访问"><a href="#Pointer与动态内存访问" class="headerlink" title="Pointer与动态内存访问"></a>Pointer与动态内存访问</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针的value（地址）和指向的变量类型</p>
<h3 id="指针的强制类型转换与运算"><a href="#指针的强制类型转换与运算" class="headerlink" title="指针的强制类型转换与运算"></a>指针的强制类型转换与运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Test</span><br><span class="line">&#123;</span><br><span class="line">   int Num;</span><br><span class="line">   char *pcName;</span><br><span class="line">   short sDate;</span><br><span class="line">   char cha[2];</span><br><span class="line">   short sBa[4];</span><br><span class="line">&#125;*p;</span><br><span class="line">假设p 的值为0x100000。如下表表达式的值分别为多少？</span><br><span class="line">   p + 0x1 &#x3D; 0x___ ?</span><br><span class="line">   (unsigned long)p + 0x1 &#x3D; 0x___?</span><br><span class="line">   (unsigned int*)p + 0x1 &#x3D; 0x___?</span><br></pre></td></tr></table></figure>
<p>一个指针变量与一个整数相加减，到底该怎么解析呢？</p>
<p>指针变量与一个整数相加减并不是用指针变量里的地址直接加减这个整数。这个整数的单位不是byte 而是元素的个数。</p>
<p>所以：p + 0x1 的值为0x100000+sizof（Test）*0x1。至于此结构体的大小为20byte，前面的章节已经详细讲解过。所以p +0x1 的值为：0x100014。</p>
<p>(unsigned long)p + 0x1 的值呢？<br>这里涉及到强制转换，将指针变量p 保存的值强制转换成无符号的长整型数。任何数值一旦被强制转换，其类型就改变了。<br>所以这个表达式其实就是一个无符号的长整型数加上另一个整数。所以其值为：0x100001。</p>
<p>(unsigned int*)p + 0x1 的值呢？<br>这里的p 被强制转换成一个指向无符号整型的指针。所以其值为：0x100000+sizof（unsigned int）*0x1，等于0x100004。</p>
<p>void*</p>
<p>const*</p>
<p>*const/const *const</p>
<p>拒绝野指针和悬垂指针</p>
<h3 id="动态分配的内存"><a href="#动态分配的内存" class="headerlink" title="动态分配的内存"></a>动态分配的内存</h3><p>malloc/free</p>
<p>new/delete</p>
<h2 id="储存类别与内存管理"><a href="#储存类别与内存管理" class="headerlink" title="储存类别与内存管理"></a>储存类别与内存管理</h2><ol>
<li>作用域</li>
</ol>
<p>块作用域：程序中可访问标识符的区域为一个块</p>
<p>文件作用域（全局变量）：定义在函数外，在整个文件可见</p>
<ol start="2">
<li>链接</li>
</ol>
<ul>
<li>无链接变量：变量属于定义他们的块</li>
<li>外部链接：多文件中使用</li>
<li>内部链接：一个翻译单元中使用（static）</li>
</ul>
<ol start="3">
<li> 储存期与静态变量</li>
</ol>
<p>储存期：对象在内存中保留了多长时间</p>
<ul>
<li><p>静态储存期：程序执行期间一直存在（具有文件作用域的变量）</p>
</li>
<li><p>线程储存期：并发</p>
</li>
<li><p>自动储存期：块作用域变量</p>
<p>ps：当在块内声明一个static变量时，它具有静态储存期但仍然是块作用域，只能在声明块内使用</p>
</li>
</ul>
<ol start="4">
<li>外部变量extern</li>
</ol>
<p>文件作用域，外部链接，静态储存期</p>
<h1 id="c-（c-11）"><a href="#c-（c-11）" class="headerlink" title="c++（c++11）"></a>c++（c++11）</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>bind,声明一个引用变量必须直接绑定</p>
<p>不要返回临时变量的引用，他会在作用域结束后被释放</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>保护数据</p>
<h2 id="Class，ADT"><a href="#Class，ADT" class="headerlink" title="Class，ADT"></a>Class，ADT</h2><p>数据抽象：定义数据成员和函数成员</p>
<p>封装：保护类的成员不被随意访问</p>
<ol>
<li>访问控制，private，public和protected</li>
</ol>
<ul>
<li>public：整个程序内可被访问</li>
<li>private:可以被类的成员函数访问，不能被使用该类的代码访问</li>
<li>protected：在讲述继承时我们将介绍</li>
</ul>
<ol start="2">
<li><p>面向对象的特性：继承，多态，封装（ADT）</p>
<p>多态的实现：</p>
</li>
</ol>
<ul>
<li><p>重载：函数名字相同但形参列表不同</p>
<p>重载运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator+(type data1,type data2)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\GK\Pictures\博客\image-20210203193631697.png" alt="image-20210203193631697"></p>
</li>
<li><p>虚函数</p>
</li>
</ul>
<ol start="3">
<li>构造函数</li>
</ol>
<ul>
<li>默认构造函数</li>
<li>构造函数初始值列表</li>
<li>拷贝构造函数</li>
</ul>
<ol start="4">
<li>析构函数</li>
</ol>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>数据抽象，继承和动态绑定</p>
<ol>
<li><p>继承：</p>
<ul>
<li>基类，虚函数，纯虚函数</li>
<li>派生类：派生类可以继承基类的成员，但派生类的成员函数不一定有权访问基类成员，能访问public而不能访问private，但有一类成员我们希望派生类有权访问但其他用户禁止访问，即为protected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 基类</span><br><span class="line">class Shape </span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      void setWidth(int w)</span><br><span class="line">      &#123;</span><br><span class="line">         width &#x3D; w;</span><br><span class="line">      &#125;</span><br><span class="line">      void setHeight(int h)</span><br><span class="line">      &#123;</span><br><span class="line">         height &#x3D; h;</span><br><span class="line">      &#125;</span><br><span class="line">   protected:</span><br><span class="line">      int width;</span><br><span class="line">      int height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 派生类</span><br><span class="line">class Rectangle: public Shape</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      int getArea()</span><br><span class="line">      &#123; </span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.setWidth(5);</span><br><span class="line">   Rect.setHeight(7);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 输出对象的面积</span><br><span class="line">   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>动态绑定</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/c++%E4%B8%8EOOP/" data-id="cklm1tp0x0001fwuca29e6u4y" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:14:30.709Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/hello-world/" data-id="cklm1tp140008fwuccpq373v2" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/Tree/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/Tree/">树与二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的数据类型"><a href="#树的数据类型" class="headerlink" title="树的数据类型"></a>树的数据类型</h2><ul>
<li><p>结点：数据元素+若干指向子树的分支</p>
</li>
<li><p>==结点的度==：分支的个数</p>
</li>
<li><p>==树的度==：树中所有结点的度的最大值</p>
</li>
<li><p>叶子结点：deg=0的结点</p>
</li>
<li><p>分支节点：deg&gt;0的结点</p>
</li>
<li><p>==结点的层次==：假设根结点的层次为1，第n层的结点的子树根结点的层次为n+1</p>
</li>
<li><p>树的深度：结点所在的最大层次，空树depth=0，只有根节点的树depth=1</p>
</li>
</ul>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li><p>对任何一棵二叉树，若它含$n_0$ 个叶子结点;</p>
<p>$n_2$个度为2的结点，则必存在关系式：</p>
<p>$n_0=n_2+1$</p>
<p>Prove:</p>
<p>$n_{sum}=n_0+n_1+n_2$</p>
<p>$分支数b=n_0+2n_2$</p>
<p>$b=n_{sum}-1$</p>
</li>
<li><p>具有n个结点的完全二叉树的深度为$[log_2n]+1$</p>
</li>
</ol>
<h2 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h2><p>一棵深度为k且有2的k次方减1个结点的二叉树是==满二叉树==。<br>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为==完全二叉树==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         1                                1</span><br><span class="line">      &#x2F;     \                          &#x2F;      \</span><br><span class="line">    2        3                        2         3</span><br><span class="line"> &#x2F;    \    &#x2F;    \                  &#x2F;     \</span><br><span class="line">4      5  6      7               4         5</span><br><span class="line">  满二叉树                              完全二叉树</span><br></pre></td></tr></table></figure>

<p>节点数和深度的关系 $n=2^k-1$</p>
<p>第i层上的节点数为$2^{i-1}$</p>
<p>​        给所有的节点编号（从1号开始而不是从零号开始）那没对于一个编号为i的节点我们可以根据i的大小，判断出他是左节点还是右节点，父节点是谁，子节点是谁。比如我们给一个编号13的节点，那么他是基数所以他是右节点，因为节点的左右变化和数据的基偶性是同步变化的。他的父节点是13/2=6(是从1好开始的)他的左子节点是13<em>2=26右子节点是13</em>2+1=27同理还可以求他的兄弟节点，父节点的父节点</p>
<p>​        总而言这在满二叉树中只要有了一个节点的编号那么他在整个二叉树中的位置就确定了，正是由于这个原因，我们更倾向于使用==顺序结构==而不是链式结构来存储满二叉树。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="中序遍历的非递归描述"><a href="#中序遍历的非递归描述" class="headerlink" title="中序遍历的非递归描述"></a>中序遍历的非递归描述</h3><ol>
<li><p>设置指针p指向当前节点，初始时指向根结点；</p>
</li>
<li><p>循环：条件：当p非空或堆栈非空</p>
<ol>
<li>如果节点p非空，则将节点<br> p压入堆栈；然后进入p的左子<br> 树p=p-&gt; Child</li>
<li>如果节点p为空，则从栈中<br> 取出一个节点Pop(S,p)访问<br> 然后进入p的右子树<br> p=p-&gt;rchild;</li>
</ol>
</li>
</ol>
<h2 id="线索链表"><a href="#线索链表" class="headerlink" title="线索链表"></a>线索链表</h2><p>左空指针指向前驱</p>
<p>右空指针指向后继</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( p &#x3D;firstNode(T); p;p &#x3D; Succ(p))</span><br><span class="line"></span><br><span class="line">   Visit (p-&gt;data);</span><br></pre></td></tr></table></figure>

<ol>
<li>中序遍历的第一个结点 ？</li>
</ol>
<p>左子树上处于“最左下”（没有左子树）的结点。</p>
<ol start="2">
<li>在中序线索化链表中结点的后继 ？</li>
</ol>
<p>若没有右子树，为后继线索所指结点。</p>
<p>否则为对其右子树进行中序遍历时访问的第一个结点；</p>
<h2 id="树与二叉树转换"><a href="#树与二叉树转换" class="headerlink" title="树与二叉树转换"></a>树与二叉树转换</h2><p>树的二叉链表表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CSNode&#123;</span><br><span class="line"></span><br><span class="line">   Elem     data;</span><br><span class="line"></span><br><span class="line">   struct CSNode *firstchild, *nextsibling;</span><br><span class="line"></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<h3 id="森林与二叉树"><a href="#森林与二叉树" class="headerlink" title="森林与二叉树"></a>森林与二叉树</h3><p>将树根看做兄弟</p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><table>
<thead>
<tr>
<th align="left">树</th>
<th align="left">二叉树</th>
<th>森林</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先序遍历</td>
<td align="left">先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td align="left">后序遍历</td>
<td align="left">中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><ol>
<li><p>第一棵树的根结点；</p>
</li>
<li><p>第一棵树的子树森林；</p>
</li>
<li><p>其它(除第一棵树外的)树构成的森林。</p>
</li>
</ol>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><p>权值低，深</p>
<p>找权值最低两个节点构造二叉树，root为权值和，直至没有独立节点</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>正则，没有deg=1的节点</li>
<li>$2n_0-1$个节点</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>霍夫曼编码，最短前缀编码</p>
<p>频率为权值，构造霍夫曼树</p>
<p>左路径为0，右路径为1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/Tree/" data-id="cklm1tp0s0000fwuc32aofce3" data-title="树与二叉树" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-array" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/array/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/array/">数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数组的顺序映像"><a href="#数组的顺序映像" class="headerlink" title="数组的顺序映像"></a>数组的顺序映像</h2><ol>
<li><p>以行序为主序(低下标优先)</p>
<ol>
<li><h3 id="n维数组储存映像"><a href="#n维数组储存映像" class="headerlink" title="n维数组储存映像"></a>n维数组储存映像</h3><p>$LOC(0,0,0,…,0)+(b_2\times…\times b_n \times j_1+b_3\times …\times b_n\times j_2+…+j_n)$</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li>以列序为主序(高下标优先)<h2 id="二维数组的链式地址定位"><a href="#二维数组的链式地址定位" class="headerlink" title="二维数组的链式地址定位"></a>二维数组的链式地址定位</h2>$LOC(j_1,j_2) = LOC(0,0) + (b_2×j_1＋j_2)×L$<br>$A[2,3]即LOC[1,2]$<br>$b_2=3$<h2 id="随机稀疏矩阵的存储"><a href="#随机稀疏矩阵的存储" class="headerlink" title="随机稀疏矩阵的存储"></a>随机稀疏矩阵的存储</h2><h3 id="n维数组储存映像-1"><a href="#n维数组储存映像-1" class="headerlink" title="n维数组储存映像"></a>n维数组储存映像</h3></li>
</ol>
<p>$LOC(0,0,0,…,0)+(b_2\times…\times b_n \times j_1+b_3\times …\times b_n\times j_2+…+j_n)$</p>
<p>## <strong>随机稀疏矩阵的存储</strong></p>
<ol>
<li><p>三元组顺序表</p>
<ul>
<li><p>i,j,data</p>
</li>
<li><p>快速转置算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpot[1] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">for (col&#x3D;2; col&lt;&#x3D;M.nu; col ++;)</span><br><span class="line"></span><br><span class="line">   cpot[col] &#x3D; cpot[col-1] + num[col-1];&#x2F;&#x2F;第col列第一个数放的位置</span><br></pre></td></tr></table></figure>

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (p&#x3D;1; p&lt;&#x3D;M.tu; ++p)&#x2F;&#x2F;把非零元素放置到正确位置</span><br><span class="line">    &#123;</span><br><span class="line">        col &#x3D; M.data[p].j; q&#x3D;cpot[col];&#x2F;&#x2F;start a col</span><br><span class="line">        T.data[q].i &#x3D; M.data[p].j;   </span><br><span class="line">        T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">        T.data[q].e &#x3D; M.data[p].e; </span><br><span class="line">        cpot[col]++;&#x2F;&#x2F;next elem</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>行逻辑链接顺序表<br>使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置</p>
</li>
<li><p>十字链表</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/array/" data-id="cklm1tp100003fwuc9oeqdh1u" data-title="数组" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-external_sort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/external_sort/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/external_sort/">外部排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="外部排序定义"><a href="#外部排序定义" class="headerlink" title="外部排序定义"></a>外部排序定义</h2><p>归并次数<br>s等于归并树的高度,m为归并段数$s=log_2m$</p>
<p>t=内部排序所需时间+外存读写所需时间+内部归并所需时间</p>
<p>读写外存次数s+1</p>
<p>10个归并段，2路归并，再假设磁盘每个物理块可容纳200个记录，则每10000个记<br> 录需要50次读50次写，共100次操作。<br> 全部排序共需要读写次数为：d=100*(4+1)=500。</p>
<h2 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h2><p>k路归并，k个数中选最小</p>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>储存败者</p>
<p>ls[0]胜者</p>
<p>设ls[t]是b[s]的父节点<br> t=(s+k)/2</p>
<p>$s\in[0,m-1]归并段序号 $</p>
<p>$h=log_2k$</p>
<ol>
<li>调整（比赛过程）</li>
<li>创建，将ls[]节点初始化为KEY_MIN</li>
<li>从b[k-1]到b[0],插入，然后调整</li>
</ol>
<h2 id="置换选择排序构造初始归并段"><a href="#置换选择排序构造初始归并段" class="headerlink" title="置换选择排序构造初始归并段"></a>置换选择排序构造初始归并段</h2><p>原始文件&gt;&gt;内存（败者树）&gt;&gt;归并段（数据有序）</p>
<h3 id="败者树规则"><a href="#败者树规则" class="headerlink" title="败者树规则"></a>败者树规则</h3><p>从WA中所有比关键字 MIINMAX大的记录中，选择最小的记录，作为新的 MIINMAX,放入归并段，直至内存空或没有比MINMAX_NOW更大的数据，在归并段中加入标记，这样就完成了一个归并段。</p>
<p>先比段号，段号小的胜利</p>
<h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><p>带权路径和WPL最小，将较大节点放在靠近根节点处，k路归并</p>
<p>添加空归并段</p>
<p>虚段数u=k-1-(m-1)%(k-1) if (m-1)%(k-1)！=0</p>
<p>将k个最小值构成一个树，根为和</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/external_sort/" data-id="cklm1tp110004fwucf5nza8m2" data-title="外部排序" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-graph" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/graph/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/graph/">图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="联通网的最小生成树"><a href="#联通网的最小生成树" class="headerlink" title="联通网的最小生成树"></a>联通网的最小生成树</h2><p>prim算法</p>
<p>与最小生成子树T与与其补集构成的割，选择最短跨边，连接的顶点加入T</p>
<h2 id="一个点到其他点最短路径"><a href="#一个点到其他点最短路径" class="headerlink" title="一个点到其他点最短路径"></a>一个点到其他点最短路径</h2><p>迪杰斯特拉算法</p>
<p>原点V0，选择与V0距离最短的点加入最短距离生成树</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>判断有向图是否存在回路</p>
<ol>
<li>从有向图中选取一个没有前驱的顶点，并输出之</li>
<li>从有向图中删去此顶点以及所有以它为尾的孤</li>
<li>重复上述两步，直至图空，或者图不空但找不到无<br> 前驱的顶点为止</li>
</ol>
<p>AOV</p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>节点VE，VL</p>
<p>边AE，AL</p>
<ol>
<li>求拓扑排序</li>
<li>按照拓扑排序求VE</li>
<li>拓扑排序逆序求VL</li>
<li>AE=弧头VE</li>
<li>AL=弧尾VL-弧Weight</li>
<li>AE=AL的弧即为关键路径</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/graph/" data-id="cklm1tp120005fwuc41ckdsyr" data-title="图" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/queue/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/queue/">队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>类似于线性表的顺序映象实现，指向表尾的指针可以作为栈顶指针。</p>
<ol>
<li>追加储存空间<br> <code>S.top = S.base + S.stacksize; //更新top指针</code><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><h2 id="进栈与上溢，出栈与下溢"><a href="#进栈与上溢，出栈与下溢" class="headerlink" title="进栈与上溢，出栈与下溢"></a>进栈与上溢，出栈与下溢</h2><h2 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h2></li>
</ol>
<h3 id="求解可能的序列数"><a href="#求解可能的序列数" class="headerlink" title="求解可能的序列数"></a>求解可能的序列数</h3><p>一般情形下，我们假设进栈序列为１，２，３，……，ｎ，可能的退栈序列有$f（ｎ）$种，对此，我们可以做如下推导：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当ｎ＝０时，ｍ（０）＝１：退栈序列为｛｝；</span><br><span class="line">当ｎ＝１时，ｍ（１）＝１：退栈序列为｛１｝；</span><br><span class="line">当ｎ＝２时，ｍ（２）＝２：</span><br><span class="line">退栈序列中１在首位，１左侧有０个数，１右侧有一个数，有ｍ（０）＊ｍ（１）种可能，１在末位，１左侧有一个数，右侧有０个数，有ｍ（１）＊ｍ（０）种，一共有ｍ（０）＊ｍ（１）＋ｍ（１）＊ｍ（０）种可能的序列。</span><br></pre></td></tr></table></figure>

<p>简单的推导中不难发现，将１置于ｉ＝１……ｎ的位置，则可能的序列数为$f（ｉ－１）\times f （ｎ－ｉ）$种。<br> 总结一下：<br> 一般的，设有n个元素序号按序号１,２，……，ｎ进栈，轮流让１在退栈序列的第１，第２，……，第ｎ位，则可能的的退栈序列种数为：<br> $f（０）\times f（ｎ－１）＋f（１）\times f（ｎ－２）＋……＋f（ｎ－１）\times f（０）<br> \＝\frac{1}{n+1}\timesＣ<em>{2n}^n<br> \＝\frac{（２ｎ）（２ｎ－１）……（ｎ＋２）}{ｎ！}$<br> 不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。<br> 反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。<br> 不合要求的2n位数与n＋1个0，n－1个1组成的排列一一对应。不符合要求方案数为$c</em>{2n}^{n+1}$</p>
<h3 id="不可能的退栈序列"><a href="#不可能的退栈序列" class="headerlink" title="不可能的退栈序列"></a>不可能的退栈序列</h3><p>设对于初始进栈序列1，2，3，……，ｎ，利用栈得到可能的退栈序列为ｐ１，ｐ２，……，ｐｉ，……，ｐｎ，</p>
<p>如果序号ｉ＜ｊ＜ｋ，且在进栈序列中ｐｉ＜ｐｊ＜ｐｋ，即：<br> ……，ｐｉ，……，ｐｊ，……，ｐｋ，……（ｐｉ＜ｐｊ＜ｐｋ）<br> 则……，ｐｋ，……，ｐｉ，……，ｐｊ，……就是不可能的退栈序列。</p>
<p>因为ｐｋ在ｐｉ和ｐｊ之后进栈，又先于ｐｉ和ｐｊ退栈，按照栈的后进先出的特性，ｐｉ压在ｐｊ的下面，理应ｐｊ先出，所以……，ｐｋ，……，ｐｉ，……，ｐｊ，……是不可能的。<br> 总结成一句话就是——当前下标大于后下标时，则后下标必定递减（或者说倒序）</p>
<p>不能先逆序再正序，即入栈序列为12345时，出栈序列54123不合法。</p>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ol>
<li><p>数制转换<br>初始化栈<br>InitStack(S);<br>依次计算当前的d进制数，并将其压栈<br>Push(S, N % 8); N = N/d;<br>依次从栈中取出计算的结果，并输出<br>Pop(S,e);<br>删除栈 DestroyStack(S); </p>
</li>
<li><p>括号匹配的检验</p>
<ol>
<li>凡出现左括弧，则进栈；</li>
<li>凡出现右括弧，首先检查栈是否空<br>若栈空，则表明该“右括弧”多余，<br>否则和栈顶元素比较，<br>若相匹配，则“左括弧出栈” ，<br>否则表明不匹配。</li>
<li>表达式检验结束时：<br>若栈空，则表明表达式中匹配正确；<br>否则表明“左括弧”有余。</li>
</ol>
</li>
<li><p>表达式求值</p>
<ol>
<li></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/queue/" data-id="cklm1tp15000afwuc7tekdp0q" data-title="队列" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-search" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/search/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/search/">查找</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><h3 id="时间性能分析-ASL"><a href="#时间性能分析-ASL" class="headerlink" title="时间性能分析 ASL"></a>时间性能分析 ASL</h3><p>$ASL=\sum_{i=1}^{n}P_iC_i$</p>
<p>$\sum P_i=1$</p>
<p>$P_i:查找到第i个字符的概率$</p>
<p>$C_i查找成功时比较过的次数$</p>
<p>eg：</p>
<p>顺序查找</p>
<p>算法的ASL= 查找成功的ASL+查找失败的ASL</p>
<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><p>折半查找，缩小区间</p>
<p>折半查找判定树</p>
<p>长度为10的折半查找判定树的具体生成过程：<br>==左孩子结点&lt;根结点&lt;右孩子结点==<br> (1)在长度为10的有序表中进行折半查找，不论查找哪个记录，都必须和中间记录进行比较，而中间记录为(1+10)/2=5（注意要取整）即判定数的的根结点为5。<br> 2)考虑判定树的左子树，即将查找区域调整到左半区，此时的查找区间为1,4],那么中间值(1+4)/2=2(注意要取整），所以做孩子根结点为2。<br> (3)考虑判定树的右子树，即将查找区域调整到右半区，此时的查找区间为[6,10],那么中间值为(6+10)2=8(注意要取整），所以做孩子根结点为8<br> (4)重复以上歩骤，依次去确定左右孩子。<br><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20160706130304182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">https://img-blog.csdn.net/20160706130304182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center</a><br>ASL分析</p>
<ol>
<li><p>折半查找是一棵二叉排序树，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值</p>
</li>
<li><p>折半查找判定树中的结点都是查找成功的情況，将每个结点的空指针指向一个实际上不存在的结点–外结点，所有外界点都是查找不成功的情況，如果有序表的长度为n,则外结点一定有n+1个。</p>
</li>
<li><p>折半查找判定树中，某结点所在的层数就是即将要比较的次数，整个判定树代表的有序表的平均査找长度即为查找每个结点的比较次数之和除以内结点个数<br> 例如：长度为10的有序表的平均查找长度为<br> ASL=(1<em>1+2</em>2+3<em>4+4</em>3)/10=29/10; </p>
</li>
<li><p>折半查找判定数中，査找不成功的次数即为査找相应外结点与内结点的比较次数。整个判定树代表的有序表的平均查找长度。查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数<br> 例如：查找失败时，长度为10的有序表的平均查找长度为<br> ASL=(3<em>5+4</em>6)/11=39/11</p>
</li>
<li><p>$ASL=log_2(n+1)-1$</p>
</li>
</ol>
<h3 id="静态最优查找树"><a href="#静态最优查找树" class="headerlink" title="静态最优查找树"></a>静态最优查找树</h3><p>带权内路径长度和最小</p>
<h3 id="索引顺序表"><a href="#索引顺序表" class="headerlink" title="索引顺序表"></a>索引顺序表</h3><p>索引表</p>
<table>
<thead>
<tr>
<th align="left">块内最大关键字</th>
<th>块起始地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>左子树&lt;根&lt;右子树<br>查找一个结点的左右子节点</p>
<ol>
<li>查找过程中，树中不存在关键字等于给定值，查找失败，插入操作只能作为叶子插入</li>
<li>查找成功后删除<ol>
<li>删除叶子结点，父节点指针域为空</li>
<li>删除只有左子树/右子树的节点，父节点相应指针域改为，指向被删除节点的左/右子树</li>
<li>删除节点既有左子树又有右子树，以前驱（左子树深度最大的右节点）替代，再删除前驱</li>
</ol>
</li>
</ol>
<h3 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h3><p>每个结点左右子树深度差不大于1，子树的子树引起失衡</p>
<ul>
<li>LL左子树的左子树引起失衡：整个树右转</li>
<li>RR</li>
<li>LR左子树的右子树引起失衡：左子树向左转，整个树右转</li>
<li>RL</li>
</ul>
<p>插入旋转与删除旋转</p>
<p>时间复杂度$O(log_2n)$</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>平衡多路查找树</p>
<p>m阶:结点最多分枝数</p>
<p>性质</p>
<ol>
<li>每个结点n个关键字，n个指向数据的指针，n+1个指向子树的指针</li>
<li>每个结点中的多个关键字均自小至大有序排列，即<br> K1≤K2≤,…&lt;Kn;<br> 指针Ai-1所指子树上所有关键字均小于K<br> 指针Ai所指子树上所有关键字均大于Ki</li>
<li>树中所有叶子结点均在树中的同一层次上<br>  根结点或为空，或至少含有两棵子树</li>
<li>其余所有结点均至少含有m/2棵子树，至多含有<br>  m棵子树；</li>
</ol>
<p>树的建立（5阶为例）</p>
<p>叶子节点的插入和节点分裂</p>
<ol>
<li><p>一棵5阶B-树，所以非根非叶结点至少要有ceil(5/2)=3个分支。根结点可以不满足这个条件，图中的根结点有两个分支。</p>
</li>
<li><p>除根结点外，结点中的关键字个数至少为2，因为分支数至少为3</p>
</li>
<li><ol>
<li><p>确定结点中关键字个数范围<br>由于题目要求建立5阶B-树，因此关键字的个数范围为</p>
<p>2（5-1/2）～4(5-1)</p>
</li>
<li><p>根结点最多可以容纳4个关键字，依次插入关键字1、2、6、7后的B-树</p>
</li>
</ol>
<p><img src="file://C:/Users/GK/Documents/Gridea/post-images/1611764409117.webp"></p>
<ol>
<li><p>==中点拆分==当插入关键字11的时候，发现此时结点中关键字的个数变为5，超出范围，需要拆分，去关键字数组中的中间位置，也就是k[3]=6，作为一个独立的结点，即新的根结点，将关键字6左、右关键字分别做成两个结点，作为新根结点的两个分支，此时树如下图所示：<br><img src="file://C:/Users/GK/Documents/Gridea/post-images/1611764430380.webp"><br>==中点进入父节点，左右被拆成两个节点==</p>
</li>
<li><p>新关键字总是插在叶子结点上，插入关键字4、8、13之后树为：<br><img src="file://C:/Users/GK/Documents/Gridea/post-images/1611764454716.webp"></p>
</li>
<li><p>可能发生连锁反应，需要新建父节点</p>
</li>
</ol>
</li>
<li><p>B-树的删除<br>删除非叶子：向前驱/后继借关键字，然后删除前驱/后继中借走的关健字<br>删除叶子： </p>
</li>
<li><p>不过少，直接删除数据和对应指针</p>
</li>
<li><p>过少，向左右借，右侧节点上顶出去父节点，父节点向下进入子节点</p>
</li>
<li><p>左右不够，剩余关键字与父节点对应关键字都加入兄弟</p>
</li>
</ol>
<p>时间性能分析</p>
<p>在含N个关键字的B-树上进行一次查找，需访问的结点个数不超过</p>
<p>$log_{[m/2]}N+1$</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树两个头指针，索引块内的每个key对应一个子树，为子树最小的key</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/search/" data-id="cklm1tp16000cfwuc40188h0s" data-title="查找" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-sort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/sort/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/sort/">排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="排序的特点"><a href="#排序的特点" class="headerlink" title="排序的特点"></a>排序的特点</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>在待排记录序列中，==任何两个关键字相同==的记录，用某种排序方法排序后==相对位置不变==，则称这种排<br> 序方法是稳定的，否则称为不稳定的</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><p>从j=i-1,从后往前扫描，R[0]为哨兵，R[0]=R[i]</p>
<p>比较次数+移动次数</p>
<p>按关键码基本有序，数据量n较小</p>
<p>==稳定==</p>
<h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><p>0为哨兵，下标1到i-1为已经有序序列，i为待插入键值</p>
<p>low=m+1,high=m-1</p>
<p>最终low=high，再进行一次比较，确定放在前面还是后面</p>
<p>==后移所有数据==high+1到i-1</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>缩小增量</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>无序序列中选出key最小数据，插入到有序序列中</p>
<p>树型选择排序，胜者树</p>
<p>==不稳定==</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>父节点和子节点有绝对大小关系</p>
<p>完全二叉树（有序表表示）</p>
<p>先构建最大堆，取最大值根结点与最后值交换，最大值已选出，不再进入排序堆，调整其他堆结构，继续选择根节点与列表中剩余值的最后一个交换，直至列表结构只剩1号位</p>
<p>==不稳定==</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>将最大值放于末尾</p>
<p>两两比较，前面比后面大则交换，最终将最大值放在末尾</p>
<p>从头开始到n-1，再重头到n-2，直到1</p>
<p>==稳定==</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>设置pivot，</p>
<p>一次快速排序</p>
<ol>
<li>将第一个记录设置为 pivot</li>
<li>从表的两端交替地向中间担描，直到两个指针相遇<br> 先从高端扫描<br> 找到第一个==比 pivotkey小==的记录<br> 将该记录移动到low指针指向的地方；<br> 再从低端扫描</li>
<li>.将 pivot移动到Iow指针位置，并返回该位置</li>
</ol>
<p>完全排序，递归的对排序得到的左右序列[1,pivotloc-1][pivotloc+1,n]进行快速排序</p>
<p>==不稳定==</p>
<p>改进，选择枢轴量，3个中选择（2k+1个中选择），先排序low，high，center，将center作为pivot放于[high-1]排序，更可能选出差不多在中间的值，进行快速排序时更可能左右分别&lt;/&gt;privot</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分组，递归归并</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>高位优先</p>
<p>低位优先<br><img src="file://C:/Users/GK/Documents/Gridea/post-images/1611794750908.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/sort/" data-id="cklm1tp17000efwucacc47mu3" data-title="排序" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/26/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/02/26/c++%E4%B8%8EOOP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/02/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/02/03/Tree/">树与二叉树</a>
          </li>
        
          <li>
            <a href="/2021/02/03/array/">数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>