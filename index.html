<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-PKG_CONFIG" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/PKG_CONFIG/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T15:21:27.000Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/26/PKG_CONFIG/">PKG_CONFIG</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简述configure、pkg-config、pkg-config-path三者的关系"><a href="#简述configure、pkg-config、pkg-config-path三者的关系" class="headerlink" title="简述configure、pkg-config、pkg_config_path三者的关系"></a>简述configure、pkg-config、pkg_config_path三者的关系</h1><p>　转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wliangde/p/3807532.html">简述configure、pkg-config、pkg_config_path三者的关系</a></p>
<h2 id="一、什么是configure"><a href="#一、什么是configure" class="headerlink" title="一、什么是configure"></a>一、什么是configure</h2><p>　　源码安装过程中大多会用到configure这个程序，一般的configure都是一个script，执行时可以传入必要参数告知配置项目。</p>
<p>　　configure程序它会根据传入的配置项目检查程序编译时所依赖的环境以及对程序编译安装进行配置，最终生成编译所需的Makefile文件供程序Make读入使用进而调用相关编译程式(通常调用编译程序都是gcc)来编译最终的二进制程序。而configure脚本在检查相应依赖环境时(例：所依赖软件的版本、相应库版本等)，通常会通过pkg-config的工具来检测相应依赖环境。</p>
<h2 id="二、什么是pkg-config"><a href="#二、什么是pkg-config" class="headerlink" title="二、什么是pkg-config"></a>二、什么是pkg-config</h2><p>　　1. pkg-config介绍</p>
<p>　　pkg-config用来检索系统中安装库文件的信息。典型的是用作库的编译和连接。如在Makefile中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">program: program.c</span><br><span class="line"> </span><br><span class="line">cc program.c &#96;pkg-config --cflags --libs gnomeui&#96;</span><br></pre></td></tr></table></figure>

<p>　　2. pkg-config功能</p>
<p>　　一般来说，如果库的头文件不在/usr/include目录中，那么在编译的时候需要用-I参数指定其路径。由于同一个库在不同系统上可能位于不同的目录下，用户安装库的时候也可以将库安装在不同的目录下，所以即使使用同一个库，由于库的路径的不同，造成了用-I参数指定的头文件的路径和在连接时使用-L参数指定lib库的路径都可能不同，其结果就是造成了编译命令界面的不统一。可能由于编译，连接的不一致，造成同一份程序从一台机器copy到另一台机器时就可能会出现问题。</p>
<p>　　pkg-config 就是用来解决编译连接界面不统一问题的一个工具。</p>
<p>　　它的基本思想：pkg-config是通过库提供的一个.pc文件获得库的各种必要信息的，包括版本信息、编译和连接需要的参数等。需要的时候可以通过pkg-config提供的参数(–cflags, –libs)，将所需信息提取出来供编译和连接使用。这样，不管库文件安装在哪，通过库对应的.pc文件就可以准确定位,可以使用相同的编译和连接命令，使得编译和连接界面统一。</p>
<p>　　它提供的主要功能有:</p>
<p>　　&lt;1&gt; 检查库的版本号。如果所需库的版本不满足要求，打印出错误信息，避免连接错误版本的库文件。<br>　　&lt;2&gt; 获得编译预处理参数，如宏定义，头文件的路径。<br>　　&lt;3&gt; 获得编译参数，如库及其依赖的其他库的位置，文件名及其他一些连接参数。<br>　　&lt;4&gt; 自动加入所依赖的其他库的设置。</p>
<p>　　3. glib-2.0的.pc文件内容举例</p>
<p>　　在默认情况下，每个支持 pkg-config 的库对应的.pc文件在安装后都位于安装目录中的lib/pkgconfig目录下。例如，我们在上面已经将Glib安装在/opt/gtk目录下了，那么这个Glib库对应的.pc文件是 /opt/gtk/lib/pkgconfig目录下一个叫glib-2.0.pc的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prefix&#x3D;&#x2F;opt&#x2F;gtk&#x2F;</span><br><span class="line">exec_prefix&#x3D;$&#123;prefix&#125;</span><br><span class="line">libdir&#x3D;$&#123;exec_prefix&#125;&#x2F;lib</span><br><span class="line">includedir&#x3D;$&#123;prefix&#125;&#x2F;include</span><br><span class="line"> </span><br><span class="line">glib_genmarshal&#x3D;glib-genmarshal</span><br><span class="line">gobject_query&#x3D;gobject-query</span><br><span class="line">glib_mkenums&#x3D;glib-mkenums</span><br><span class="line"> </span><br><span class="line">Name: GLib</span><br><span class="line">Description: C Utility Library</span><br><span class="line">Version: 2.12.13</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lglib-2.0</span><br><span class="line">Cflags: -I$&#123;includedir&#125;&#x2F;glib-2.0 -I$&#123;libdir&#125;&#x2F;glib-2.0&#x2F;include</span><br></pre></td></tr></table></figure>



<p>　　2. pkg-config –list-all</p>
<p>　　列出所有可使用的包，位置在/usr/lib/pkgconfig ,此目录下都是各种.pc文件。/usr/local/lib/pkgconfig下面的libname.pc文件，新软件一般都会安装.pc文件，没有可以自己创建，并且设置环境变量PKG_CONFIG_PATH寻找.pc文件路径。<br>　　使用 pkg-config 的 –cflags 参数可以给出在编译时所需要的选项，而 –libs 参数可以给出连接时的选项。例如，假设一个 sample.c 的程序用到了 Glib 库，就可以这样编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c &#96;pkg-config --cflags glib-2.0&#96; sample.c</span><br></pre></td></tr></table></figure>

<p>　　然后这样连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc sample.o -o sample &#96;pkg-config --libs glib-2.0&#96;</span><br></pre></td></tr></table></figure>

<p>　　或者上面两步也可以合并为以下一步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc sample.c -o sample &#96;pkg-config --cflags --libs glib-2.0&#96;</span><br></pre></td></tr></table></figure>
<p>　　可以看到：由于使用了pkg-config工具来获得库的选项，所以不论库安装在什么目录下，都可以使用相同的编译和连接命令，带来了编译和连接界面的统一。</p>
<p>　　使用pkg-config工具提取库的编译和连接参数有两个基本的前提：</p>
<p>　　&lt;1&gt; 库本身在安装的时候必须提供一个相应的.pc文件。不这样做的库说明不支持pkg-config工具的使用。<br>　　&lt;2&gt; pkg-config必须知道要到哪里去寻找此.pc 文件。</p>
<p>　　4、 环境变量PKG_CONFIG_PATH</p>
<p>　　环境变量PKG_CONFIG_PATH是用来设置.pc文件的搜索路径的，pkg-config按照设置路径的先后顺序进行搜索，直到找到指定的.pc 文件为止。这样，库的头文件的搜索路径的设置实际上就变成了对.pc文件搜索路径的设置。</p>
<p>　　在安装完一个需要使用的库后，比如Glib，一是将相应的.pc文件，如glib-2.0.pc拷贝到/usr/lib/pkgconfig目录下，二是通过设置环境变量PKG_CONFIG_PATH添加glib-2.0.pc文件的搜索路径。</p>
<p>　　添加环境变量PKG_CONFIG_PATH，在bash中应该进行如下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PKG_CONFIG_PATH&#x3D;&#x2F;opt&#x2F;gtk&#x2F;lib&#x2F;pkgconfig:$PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>　　可以执行下面的命令检查是否 /opt/gtk/lib/pkgconfig 路径已经设置在PKG_CONFIG_PATH环境变量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>　　这样设置之后，使用Glib库的其它程序或库在编译的时候pkg-config就知道首先要到/opt/gtk/lib/pkgconfig这个目录中去寻找glib-2.0.pc了(GTK+和其它的依赖库的.pc文件也将拷贝到这里，也会首先到这里搜索它们对应的.pc文件)。之后，通过pkg-config就可以把其中库的编译和连接参数提取出来供程序在编译和连接时使用。</p>
<p>　　另外还需要注意的是：环境变量的设置只对当前的终端窗口有效。如果到了没有进行上述设置的终端窗口中，pkg-config将找不到新安装的glib-2.0.pc文件、从而可能使后面进行的安装(如Glib之后的Atk的安装)无法进行。</p>
<p>　　在我们采用的安装方案中，由于是使用环境变量对GTK+及其依赖库进行的设置，所以当系统重新启动、或者新开一个终端窗口之后，如果想使用新安装的GTK+库，需要如上面那样重新设置PKG_CONFIG_PATH和LD_LIBRARY_PATH环境变量。</p>
<p>　　这种使用GTK+的方法，在使用之前多了一个对库进行设置的过程。虽然显得稍微繁琐了一些，但却是一种最安全的使用GTK+库的方式，不会对系统上已经存在的使用了GTK+库的程序(比如GNOME桌面)带来任何冲击。</p>
<p>　为了使库的设置变得简单一些，可以把下面的这两句设置保存到一个文件中(比如set_gtk-2.10 文件):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH&#x3D;&#x2F;opt&#x2F;gtk&#x2F;lib&#x2F;pkgconfig:$PKG_CONFIG_PATH</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gtk&#x2F;lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>　　其中的环境变量LD_LIBRARY_PATH变量主要是添加新安装库的搜索路径。之后，就可以用下面的方法进行库的设置了(其中的source命令也可以用.代替)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source set_gtk-2.10</span><br></pre></td></tr></table></figure>

<p>　　只有在用新版的GTK+库开发应用程序、或者运行使用了新版GTK+库的程序的时候，才有必要进行上述设置。</p>
<p>　　如果想避免使用GTK+库之前上述设置的麻烦，可以把上面两个环境变量的设置在系统的配置文件中(如 /etc/profile)或者自己的用户配置文件中(如 <del>/.bash_profile) ；库的搜索路径也可以设置在 /etc/ld.so.conf 文件中，等等。这种设置在系统启动时会生效，从而会导致使用 GTK+ 的程序使用新版的 GTK+ 运行库，这有可能会带来一些问题。当然，如果你发现用新版的GTK+代替旧版没有什么问题的话，使用这种设置方式是比较方便的。加入到</del>/.bashrc中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PKG_CONFIG_PATH&#x3D;&#x2F;opt&#x2F;gtk&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>

<p>　　重启之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $PKG_CONFIG_PATH</span><br><span class="line">&#x2F;opt&#x2F;gtk&#x2F;lib&#x2F;pkgconfig</span><br></pre></td></tr></table></figure>

<h2 id="三、运行时库的连接"><a href="#三、运行时库的连接" class="headerlink" title="三、运行时库的连接"></a>三、运行时库的连接</h2><p>　　库文件在连接(静态库和共享库)和运行(仅限于使用共享库的程序)时被使用，其搜索路径是在系统中进行设置的。一般Linux系统把/lib和/usr/lib两个目录作为默认的库搜索路径，所以使用这两个目录中的库是不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到 库的搜索路径之中。设置库文件的搜索路径有下列两种方式，可任选其一使用：</p>
<p>　　&lt;1&gt; 在环境变量 LD_LIBRARY_PATH 中指明库的搜索路径。<br>　　&lt;2&gt; 在/etc/ld.so.conf 文件中添加库的搜索路径。</p>
<p>　　将自己可能存放库文件的路径都加入到/etc/ld.so.conf中是明智的选择 ^_^</p>
<p>　　添加方法也极其简单，将库文件的绝对路径直接写进去就OK了，一行一个。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;X11R6&#x2F;lib </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib </span><br><span class="line">&#x2F;opt&#x2F;lib</span><br></pre></td></tr></table></figure>


<p>　　需要注意的是：第二种搜索路径的设置方式对于程序连接时的库(包括共享库和静态库)的定位已经足够了，但是对于使用了共享库的程序的执行还是不够的。这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache从中进行搜索的。/etc/ld.so.cache是一个非文本的数据文件，不能直接编辑，它是根据/etc/ld.so.conf中设置的搜索路径由/sbin/ldconfig命令将这些搜索路径下的共享库文件集中在一起而生成的(ldconfig命令要以root权限执行)。因此，为了保证程序执行时对库的定位，在/etc/ld.so.conf中进行了库搜索路径的设置之后，还必须要运行/sbin/ldconfig命令更新/etc/ld.so.cache文件之后才可以。ldconfig简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用。因此当安装完一些库文件(例如刚安装好glib)，或者修改ld.so.conf增加新的库路径后，需要运行一下 /sbin/ldconfig使所有的库文件都被缓存到ld.so.cache中，如果没做，即使库文件明明就在/usr/lib下的，也是不会被使用的，结果编译过程中抱错，缺少xxx库，去查看发现明明就在那放着，搞的想大骂computer蠢猪一个。 ^_^</p>
<p>　　在程序连接时，对于库文件(静态库和共享库)的搜索路径，除了上面的设置方式之外，还可以通过-L参数显式指定。因为用-L设置的路径将被优先搜索，所以在连接的时候通常都会以这种方式直接指定要连接的库的路径。</p>
<p>　　前面已经说明过了，库搜索路径的设置有两种方式：在环境变量LD_LIBRARY_PATH中设置以及在/etc/ld.so.conf文件中设置。其中，第二种设置方式需要root权限，以改变/etc/ld.so.conf文件并执行/sbin/ldconfig命令。而且，当系统重新启动后，所有的基于GTK2的程序在运行时都将使用新安装的GTK+库。不幸的是，由于GTK+版本的改变，这有时会给应用程序带来兼容性的问题，造成某些程序运行不正常。为了避免出现上面的这些情况，在GTK+及其依赖库的安装过程中对于库的搜索路径的设置将采用第一种方式进行。这种设置方式不需要root权限，设置也简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export LD_LIBRARY_PATH&#x3D;&#x2F;opt&#x2F;gtk&#x2F;lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>　　可以用下面的命令查看 LD_LIBRAY_PATH 的设置内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>　　至此，库的两种设置就完成了。</p>
<h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><p>　　<a target="_blank" rel="noopener" href="http://www.91linux.com/html/article/program/cpp/20071207/8934.html">ld.so.conf 文件与PKG_CONFIG_PATH变量</a><br>　　<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/u1/44908/showart_1799050.html">pkg-config使用</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/PKG_CONFIG/" data-id="cklmi0hts0000bwucfhfwhui0" data-title="PKG_CONFIG" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cmake/" rel="tag">Cmake</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-安装OpenCvCpp库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/%E5%AE%89%E8%A3%85OpenCvCpp%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:45:20.000Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/26/%E5%AE%89%E8%A3%85OpenCvCpp%E5%BA%93/">安装OpenCvC++库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在Ubuntu上安装OpenCV和contrib库"><a href="#在Ubuntu上安装OpenCV和contrib库" class="headerlink" title="在Ubuntu上安装OpenCV和contrib库"></a>在Ubuntu上安装OpenCV和contrib库</h1><p>自从进入3.X时代以后，OpenCV将代码库分成了两部分，分别是稳定的核心功能库opencv库和试验性质的contrib库。</p>
<h2 id="OpenCV-Contrib库"><a href="#OpenCV-Contrib库" class="headerlink" title="OpenCV Contrib库"></a>OpenCV Contrib库</h2><p>OpenCV Contrib库是非官方的第三方开发扩充库。通过这个库，我们能使用如dnn、相机标注、3D成像、ArUco、物体追踪，背景分割三维重建，SURF、SIFT特征点提取算法等功能。</p>
<h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><ul>
<li>ubuntu18.04</li>
<li>Cmake&gt;=3.10.2</li>
<li>unzip</li>
</ul>
<h2 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssl libssl-dev mingetty zip unzip git curl vim gcc g++ -y</span><br><span class="line">sudo apt install socat zsh  curl git vim make cmake -y</span><br><span class="line">sudo apt install autojump -y</span><br><span class="line">sudo apt-get install -y libtiff5-dev libeigen3-dev</span><br><span class="line">sudo apt install -y git gcc g++ make cmake libgtk2.0-dev libgoogle-glog-dev </span><br><span class="line">sudo apt install -y libtesseract-dev libgtkglext1 libgtkglext1-dev ffmpeg</span><br><span class="line">sudo apt install -y libv4l-0 libv4l-dev</span><br><span class="line">sudo apt install -y liblapacke-dev libopenblas-dev libgtk-3-dev libgstreamer-plugins-base1.0-dev </span><br><span class="line">sudo apt install -y libgstreamer1.0-dev libavresample-dev libgphoto2-dev libdc1394-22-dev</span><br><span class="line">sudo apt-get install -y build-essential make cmake cmake-curses-gui git g++ pkg-config curl</span><br><span class="line">sudo apt-get install -y libavcodec-dev libavformat-dev libavutil-dev libswscale-dev libeigen3-dev libglew-dev libgtk2.0-dev</span><br><span class="line">sudo apt-get install -y libtbb2 libtbb-dev v4l-utils qv4l2 v4l2ucp</span><br><span class="line">sudo apt-get install -y libdc1394-22-dev libxine2-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</span><br><span class="line">sudo apt-get install -y libjpeg8-dev libjpeg-turbo8-dev libtiff-dev libpng-dev</span><br><span class="line">sudo apt-get install -y libxvidcore-dev libx264-dev libgtk-3-dev</span><br><span class="line">sudo apt-get install -y libatlas-base-dev libopenblas-dev liblapack-dev liblapacke-dev gfortran</span><br><span class="line">sudo apt-get install -y qt5-default</span><br><span class="line">sudo apt-get install -y python3-dev python3-testresources</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h3><p>选择合适的opencv版本，contrib库版本需与opencv版本相同，以目前使用的3.4.7为例，下载zip压缩包</p>
<p><a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/releases/tag/3.4.7">OpenCV3.4.7</a><img src="C:\Users\GK\Pictures\博客\image-20210226180037337.png" alt="image-20210226180037337"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/opencv/opencv_contrib/releases/tag/3.4.7">OpenCV-Contrib</a></p>
<p><img src="C:\Users\GK\Pictures\博客\image-20210226180948631.png" alt="image-20210226180948631"></p>
<p>使用shell将源代码下载并放入一个文件夹内</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget -O opencv.zip https://github.com/opencv/opencv/archive/[version_id].zip</span><br><span class="line">wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/[version_id].zip</span><br><span class="line">unzip opencv.zip</span><br><span class="line">unzip opencv_contrib.zip</span><br><span class="line">mv opencv-[version_id] opencv</span><br><span class="line">mv opencv_contrib-[version_id] opencv_contrib</span><br></pre></td></tr></table></figure>

<h3 id="配置cmake并编译OpenCV"><a href="#配置cmake并编译OpenCV" class="headerlink" title="配置cmake并编译OpenCV"></a>配置cmake并编译OpenCV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;opencv</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>

<p>Cmake编译命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cmake   -D CMAKE_BUILD_TYPE&#x3D;RELEASE \</span><br><span class="line">        -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local \</span><br><span class="line">        -D ENABLE_NEON&#x3D;ON \</span><br><span class="line">        -D ENABLE_FAST_MATH&#x3D;ON \</span><br><span class="line">        -D WITH_GSTREAMER&#x3D;ON \</span><br><span class="line">        -D WITH_LIBV4L&#x3D;ON \</span><br><span class="line">        -D BUILD_opencv_python2&#x3D;OFF \</span><br><span class="line">        -D BUILD_opencv_python3&#x3D;ON \</span><br><span class="line">        -D BUILD_TESTS&#x3D;OFF \</span><br><span class="line">        -D BUILD_PERF_TESTS&#x3D;OFF \</span><br><span class="line">        -D BUILD_EXAMPLES&#x3D;OFF  \</span><br><span class="line">        -D WITH_TBB&#x3D;ON \</span><br><span class="line">        -D BUILD_opencv_world&#x3D;OFF \</span><br><span class="line">        -D WITH_OPENGL&#x3D;ON \</span><br><span class="line">        -D WITH_GTK_2_X&#x3D;ON \</span><br><span class="line">        -D OPENCV_ENABLE_NONFREE&#x3D;ON \</span><br><span class="line">        -D EIGEN_INCLUDE_PATH&#x3D;&quot;&#x2F;usr&#x2F;include&#x2F;eigen3&quot; \</span><br><span class="line">        -D WITH_XINE&#x3D;ON \</span><br><span class="line">        -D WITH_GDAL&#x3D;ON \</span><br><span class="line">        ..</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>此处8为最大支持线程数，一般为cpu数两倍，一般情况下为4核8线程，线程数过多时可能减低编译效率，设置导致编译报错。</p>
<p>make时如看到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">make: * No targets specified and no makefile found.  Stop.</span><br></pre></td></tr></table></figure>

<p>此时问题为Cmake出现问题，请查看Cmake报错信息</p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><p>编译成功后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/bash.bashrc</span><br></pre></td></tr></table></figure>

<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig  </span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>保存退出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bash.bashrc</span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure>

<p>配置生效</p>
<p>查看Linux opencv安装库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --libs</span><br></pre></td></tr></table></figure>

<p>查看安装版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config opencv --modversion</span><br></pre></td></tr></table></figure>



<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>将如下程序复制至opencv_test.cpp中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 1. A simple OpenCV program that loads an image from disk and displays it on the screen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">char</span>** argv )</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">	&lt;&lt; <span class="string">&quot;A simple OpenCV program that loads and displays an image from disk\n&quot;</span></span><br><span class="line">	&lt;&lt; argv[<span class="number">0</span>] &lt;&lt;<span class="string">&quot; &lt;path/filename&gt;\n&quot;</span></span><br><span class="line">	&lt;&lt; <span class="string">&quot;For example:\n&quot;</span></span><br><span class="line">	&lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; ../fruits.jpg\n&quot;</span></span><br><span class="line">	&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		help(argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">  cv::Mat img = cv::imread( argv[<span class="number">1</span>], <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( img.empty() ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  cv::namedWindow( <span class="string">&quot;Example&quot;</span>, cv::WINDOW_AUTOSIZE );</span><br><span class="line">  cv::imshow( <span class="string">&quot;Example&quot;</span>, img );</span><br><span class="line">  cv::waitKey( <span class="number">0</span> );</span><br><span class="line">  cv::destroyWindow( <span class="string">&quot;Example&quot;</span> );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>保存并编译该程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp `pkg-config --libs --cflags opencv`</span><br></pre></td></tr></table></figure>

<p>运行程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>按程序执行即可，不报错即为安装成功</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/%E5%AE%89%E8%A3%85OpenCvCpp%E5%BA%93/" data-id="cklmi0hua000lbwuchk0640t9" data-title="安装OpenCvC++库" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-相机模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:43:16.096Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h1><h2 id="相机传感器型号与对应参数"><a href="#相机传感器型号与对应参数" class="headerlink" title="相机传感器型号与对应参数"></a>相机传感器型号与对应参数</h2><table>
<thead>
<tr>
<th>格式</th>
<th>宽度</th>
<th>长度</th>
<th>对角线</th>
<th>面积</th>
<th>焦距系数</th>
</tr>
</thead>
<tbody><tr>
<td>中画幅</td>
<td>33.0</td>
<td>44.0</td>
<td>55.0</td>
<td>1452</td>
<td>0.7</td>
</tr>
<tr>
<td>全画幅</td>
<td>24.0</td>
<td>36.0</td>
<td>43.4</td>
<td>864</td>
<td>1.0</td>
</tr>
<tr>
<td>Red Epic</td>
<td>14.6</td>
<td>27.7</td>
<td>31.3</td>
<td>404</td>
<td>1.3</td>
</tr>
<tr>
<td>Super 35mm</td>
<td>13.8</td>
<td>24.6</td>
<td>28.0</td>
<td>339</td>
<td>1.4</td>
</tr>
<tr>
<td>APS-C</td>
<td>15.6</td>
<td>23.5</td>
<td>28.3</td>
<td>368</td>
<td>1.5</td>
</tr>
<tr>
<td>1.5”</td>
<td>14.0</td>
<td>18.7</td>
<td>23.4</td>
<td>262</td>
<td>1.9</td>
</tr>
<tr>
<td>4/3</td>
<td>13.5</td>
<td>18.0</td>
<td>22.4</td>
<td>243</td>
<td>2.0</td>
</tr>
<tr>
<td>2/3”</td>
<td>6.6</td>
<td>8.8</td>
<td>11.0</td>
<td>58</td>
<td>4.0</td>
</tr>
<tr>
<td>1/1.7”</td>
<td>5.6</td>
<td>7.4</td>
<td>9.5</td>
<td>42</td>
<td>4.6</td>
</tr>
<tr>
<td>1/2”</td>
<td>4.8</td>
<td>6.4</td>
<td>8.0</td>
<td>31</td>
<td>5.4</td>
</tr>
<tr>
<td>1/2.5”</td>
<td>4.3</td>
<td>5.8</td>
<td>7.2</td>
<td>25</td>
<td>6.0</td>
</tr>
<tr>
<td>1/3”</td>
<td>3.6</td>
<td>4.8</td>
<td>6.0</td>
<td>17</td>
<td>7.2</td>
</tr>
</tbody></table>
<p>图像传感器感光区域的面积大小。这个尺寸直接决定了整个系统的物理放大率。如：1/3”、1/2”等。绝大多数模拟相机的传感器的长宽比例是4：3(H：V)，数字相机的长宽比例则包括多种：1：1，16：9，3：2 etc。注意相机尺寸的 1”=16mm≠25.4mm</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/" data-id="cklmi0huf000rbwucf9pt7490" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c++与OOP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/c++%E4%B8%8EOOP/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:43:16.015Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C（拒绝goto）"><a href="#C（拒绝goto）" class="headerlink" title="C（拒绝goto）"></a>C（拒绝goto）</h1><h2 id="Struct-Enum-Union"><a href="#Struct-Enum-Union" class="headerlink" title="Struct,Enum,Union"></a>Struct,Enum,Union</h2><ul>
<li>结构体的初始化和声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">    int Code;</span><br><span class="line">    char Name[20];</span><br><span class="line">    char Sex;</span><br><span class="line">    int Age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student Stu;</span><br><span class="line">struct Student Stu[10];</span><br><span class="line">struct Student *pStru;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">    int Code;</span><br><span class="line">    char Name[20];</span><br><span class="line">    char Sex;</span><br><span class="line">    int Age;</span><br><span class="line">&#125;Stu,Stu[10],*pStu;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int Code;</span><br><span class="line">    char Name[20];</span><br><span class="line">    char Sex;</span><br><span class="line">    int Age;</span><br><span class="line">&#125;Student;</span><br><span class="line">Student Stu,Stu[10],*pStu;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。</p>
<ul>
<li>用结构储存串</li>
</ul>
<p>指针还是数组，一般情况下选择定长数组，如果使用指针，必须预先分配足够的空间</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>声明函数形式参数和返回值</p>
<h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>实际参数是具体的值，形式参数是变量</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数调用自己</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数具有唯一的返回值，且不能返回引用</p>
<h2 id="Pointer与动态内存访问"><a href="#Pointer与动态内存访问" class="headerlink" title="Pointer与动态内存访问"></a>Pointer与动态内存访问</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针的value（地址）和指向的变量类型</p>
<h3 id="指针的强制类型转换与运算"><a href="#指针的强制类型转换与运算" class="headerlink" title="指针的强制类型转换与运算"></a>指针的强制类型转换与运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Test</span><br><span class="line">&#123;</span><br><span class="line">   int Num;</span><br><span class="line">   char *pcName;</span><br><span class="line">   short sDate;</span><br><span class="line">   char cha[2];</span><br><span class="line">   short sBa[4];</span><br><span class="line">&#125;*p;</span><br><span class="line">假设p 的值为0x100000。如下表表达式的值分别为多少？</span><br><span class="line">   p + 0x1 &#x3D; 0x___ ?</span><br><span class="line">   (unsigned long)p + 0x1 &#x3D; 0x___?</span><br><span class="line">   (unsigned int*)p + 0x1 &#x3D; 0x___?</span><br></pre></td></tr></table></figure>
<p>一个指针变量与一个整数相加减，到底该怎么解析呢？</p>
<p>指针变量与一个整数相加减并不是用指针变量里的地址直接加减这个整数。这个整数的单位不是byte 而是元素的个数。</p>
<p>所以：p + 0x1 的值为0x100000+sizof（Test）*0x1。至于此结构体的大小为20byte，前面的章节已经详细讲解过。所以p +0x1 的值为：0x100014。</p>
<p>(unsigned long)p + 0x1 的值呢？<br>这里涉及到强制转换，将指针变量p 保存的值强制转换成无符号的长整型数。任何数值一旦被强制转换，其类型就改变了。<br>所以这个表达式其实就是一个无符号的长整型数加上另一个整数。所以其值为：0x100001。</p>
<p>(unsigned int*)p + 0x1 的值呢？<br>这里的p 被强制转换成一个指向无符号整型的指针。所以其值为：0x100000+sizof（unsigned int）*0x1，等于0x100004。</p>
<p>void*</p>
<p>const*</p>
<p>*const/const *const</p>
<p>拒绝野指针和悬垂指针</p>
<h3 id="动态分配的内存"><a href="#动态分配的内存" class="headerlink" title="动态分配的内存"></a>动态分配的内存</h3><p>malloc/free</p>
<p>new/delete</p>
<h2 id="储存类别与内存管理"><a href="#储存类别与内存管理" class="headerlink" title="储存类别与内存管理"></a>储存类别与内存管理</h2><ol>
<li>作用域</li>
</ol>
<p>块作用域：程序中可访问标识符的区域为一个块</p>
<p>文件作用域（全局变量）：定义在函数外，在整个文件可见</p>
<ol start="2">
<li>链接</li>
</ol>
<ul>
<li>无链接变量：变量属于定义他们的块</li>
<li>外部链接：多文件中使用</li>
<li>内部链接：一个翻译单元中使用（static）</li>
</ul>
<ol start="3">
<li> 储存期与静态变量</li>
</ol>
<p>储存期：对象在内存中保留了多长时间</p>
<ul>
<li><p>静态储存期：程序执行期间一直存在（具有文件作用域的变量）</p>
</li>
<li><p>线程储存期：并发</p>
</li>
<li><p>自动储存期：块作用域变量</p>
<p>ps：当在块内声明一个static变量时，它具有静态储存期但仍然是块作用域，只能在声明块内使用</p>
</li>
</ul>
<ol start="4">
<li>外部变量extern</li>
</ol>
<p>文件作用域，外部链接，静态储存期</p>
<h1 id="c-（c-11）"><a href="#c-（c-11）" class="headerlink" title="c++（c++11）"></a>c++（c++11）</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>bind,声明一个引用变量必须直接绑定</p>
<p>不要返回临时变量的引用，他会在作用域结束后被释放</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>保护数据</p>
<h2 id="Class，ADT"><a href="#Class，ADT" class="headerlink" title="Class，ADT"></a>Class，ADT</h2><p>数据抽象：定义数据成员和函数成员</p>
<p>封装：保护类的成员不被随意访问</p>
<ol>
<li>访问控制，private，public和protected</li>
</ol>
<ul>
<li>public：整个程序内可被访问</li>
<li>private:可以被类的成员函数访问，不能被使用该类的代码访问</li>
<li>protected：在讲述继承时我们将介绍</li>
</ul>
<ol start="2">
<li><p>面向对象的特性：继承，多态，封装（ADT）</p>
<p>多态的实现：</p>
</li>
</ol>
<ul>
<li><p>重载：函数名字相同但形参列表不同</p>
<p>重载运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator+(type data1,type data2)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\GK\Pictures\博客\image-20210203193631697.png" alt="image-20210203193631697"></p>
</li>
<li><p>虚函数</p>
</li>
</ul>
<ol start="3">
<li>构造函数</li>
</ol>
<ul>
<li>默认构造函数</li>
<li>构造函数初始值列表</li>
<li>拷贝构造函数</li>
</ul>
<ol start="4">
<li>析构函数</li>
</ol>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>数据抽象，继承和动态绑定</p>
<ol>
<li><p>继承：</p>
<ul>
<li>基类，虚函数，纯虚函数</li>
<li>派生类：派生类可以继承基类的成员，但派生类的成员函数不一定有权访问基类成员，能访问public而不能访问private，但有一类成员我们希望派生类有权访问但其他用户禁止访问，即为protected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 基类</span><br><span class="line">class Shape </span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      void setWidth(int w)</span><br><span class="line">      &#123;</span><br><span class="line">         width &#x3D; w;</span><br><span class="line">      &#125;</span><br><span class="line">      void setHeight(int h)</span><br><span class="line">      &#123;</span><br><span class="line">         height &#x3D; h;</span><br><span class="line">      &#125;</span><br><span class="line">   protected:</span><br><span class="line">      int width;</span><br><span class="line">      int height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 派生类</span><br><span class="line">class Rectangle: public Shape</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      int getArea()</span><br><span class="line">      &#123; </span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.setWidth(5);</span><br><span class="line">   Rect.setHeight(7);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 输出对象的面积</span><br><span class="line">   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>动态绑定</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/c++%E4%B8%8EOOP/" data-id="cklmi0hu00003bwuc7w46hz1j" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/26/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-02-26T08:14:30.709Z" itemprop="datePublished">2021-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/26/hello-world/" data-id="cklmi0hu40009bwuc2eaab824" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-array" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/array/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/array/">数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数组的顺序映像"><a href="#数组的顺序映像" class="headerlink" title="数组的顺序映像"></a>数组的顺序映像</h2><ol>
<li><p>以行序为主序(低下标优先)</p>
<ol>
<li><h3 id="n维数组储存映像"><a href="#n维数组储存映像" class="headerlink" title="n维数组储存映像"></a>n维数组储存映像</h3><p>$LOC(0,0,0,…,0)+(b_2\times…\times b_n \times j_1+b_3\times …\times b_n\times j_2+…+j_n)$</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li>以列序为主序(高下标优先)<h2 id="二维数组的链式地址定位"><a href="#二维数组的链式地址定位" class="headerlink" title="二维数组的链式地址定位"></a>二维数组的链式地址定位</h2>$LOC(j_1,j_2) = LOC(0,0) + (b_2×j_1＋j_2)×L$<br>$A[2,3]即LOC[1,2]$<br>$b_2=3$<h2 id="随机稀疏矩阵的存储"><a href="#随机稀疏矩阵的存储" class="headerlink" title="随机稀疏矩阵的存储"></a>随机稀疏矩阵的存储</h2><h3 id="n维数组储存映像-1"><a href="#n维数组储存映像-1" class="headerlink" title="n维数组储存映像"></a>n维数组储存映像</h3></li>
</ol>
<p>$LOC(0,0,0,…,0)+(b_2\times…\times b_n \times j_1+b_3\times …\times b_n\times j_2+…+j_n)$</p>
<p>## <strong>随机稀疏矩阵的存储</strong></p>
<ol>
<li><p>三元组顺序表</p>
<ul>
<li><p>i,j,data</p>
</li>
<li><p>快速转置算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpot[1] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">for (col&#x3D;2; col&lt;&#x3D;M.nu; col ++;)</span><br><span class="line"></span><br><span class="line">   cpot[col] &#x3D; cpot[col-1] + num[col-1];&#x2F;&#x2F;第col列第一个数放的位置</span><br></pre></td></tr></table></figure>

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (p&#x3D;1; p&lt;&#x3D;M.tu; ++p)&#x2F;&#x2F;把非零元素放置到正确位置</span><br><span class="line">    &#123;</span><br><span class="line">        col &#x3D; M.data[p].j; q&#x3D;cpot[col];&#x2F;&#x2F;start a col</span><br><span class="line">        T.data[q].i &#x3D; M.data[p].j;   </span><br><span class="line">        T.data[q].j &#x3D; M.data[p].i;</span><br><span class="line">        T.data[q].e &#x3D; M.data[p].e; </span><br><span class="line">        cpot[col]++;&#x2F;&#x2F;next elem</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>行逻辑链接顺序表<br>使用数组 rpos 记录矩阵中每行第一个非 0 元素在一维数组中的存储位置</p>
</li>
<li><p>十字链表</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/array/" data-id="cklmi0htx0001bwuce0f73q8w" data-title="数组" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/Tree/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/Tree/">树与二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的数据类型"><a href="#树的数据类型" class="headerlink" title="树的数据类型"></a>树的数据类型</h2><ul>
<li><p>结点：数据元素+若干指向子树的分支</p>
</li>
<li><p>==结点的度==：分支的个数</p>
</li>
<li><p>==树的度==：树中所有结点的度的最大值</p>
</li>
<li><p>叶子结点：deg=0的结点</p>
</li>
<li><p>分支节点：deg&gt;0的结点</p>
</li>
<li><p>==结点的层次==：假设根结点的层次为1，第n层的结点的子树根结点的层次为n+1</p>
</li>
<li><p>树的深度：结点所在的最大层次，空树depth=0，只有根节点的树depth=1</p>
</li>
</ul>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li><p>对任何一棵二叉树，若它含$n_0$ 个叶子结点;</p>
<p>$n_2$个度为2的结点，则必存在关系式：</p>
<p>$n_0=n_2+1$</p>
<p>Prove:</p>
<p>$n_{sum}=n_0+n_1+n_2$</p>
<p>$分支数b=n_0+2n_2$</p>
<p>$b=n_{sum}-1$</p>
</li>
<li><p>具有n个结点的完全二叉树的深度为$[log_2n]+1$</p>
</li>
</ol>
<h2 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h2><p>一棵深度为k且有2的k次方减1个结点的二叉树是==满二叉树==。<br>深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为==完全二叉树==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         1                                1</span><br><span class="line">      &#x2F;     \                          &#x2F;      \</span><br><span class="line">    2        3                        2         3</span><br><span class="line"> &#x2F;    \    &#x2F;    \                  &#x2F;     \</span><br><span class="line">4      5  6      7               4         5</span><br><span class="line">  满二叉树                              完全二叉树</span><br></pre></td></tr></table></figure>

<p>节点数和深度的关系 $n=2^k-1$</p>
<p>第i层上的节点数为$2^{i-1}$</p>
<p>​        给所有的节点编号（从1号开始而不是从零号开始）那没对于一个编号为i的节点我们可以根据i的大小，判断出他是左节点还是右节点，父节点是谁，子节点是谁。比如我们给一个编号13的节点，那么他是基数所以他是右节点，因为节点的左右变化和数据的基偶性是同步变化的。他的父节点是13/2=6(是从1好开始的)他的左子节点是13<em>2=26右子节点是13</em>2+1=27同理还可以求他的兄弟节点，父节点的父节点</p>
<p>​        总而言这在满二叉树中只要有了一个节点的编号那么他在整个二叉树中的位置就确定了，正是由于这个原因，我们更倾向于使用==顺序结构==而不是链式结构来存储满二叉树。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="中序遍历的非递归描述"><a href="#中序遍历的非递归描述" class="headerlink" title="中序遍历的非递归描述"></a>中序遍历的非递归描述</h3><ol>
<li><p>设置指针p指向当前节点，初始时指向根结点；</p>
</li>
<li><p>循环：条件：当p非空或堆栈非空</p>
<ol>
<li>如果节点p非空，则将节点<br> p压入堆栈；然后进入p的左子<br> 树p=p-&gt; Child</li>
<li>如果节点p为空，则从栈中<br> 取出一个节点Pop(S,p)访问<br> 然后进入p的右子树<br> p=p-&gt;rchild;</li>
</ol>
</li>
</ol>
<h2 id="线索链表"><a href="#线索链表" class="headerlink" title="线索链表"></a>线索链表</h2><p>左空指针指向前驱</p>
<p>右空指针指向后继</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( p &#x3D;firstNode(T); p;p &#x3D; Succ(p))</span><br><span class="line"></span><br><span class="line">   Visit (p-&gt;data);</span><br></pre></td></tr></table></figure>

<ol>
<li>中序遍历的第一个结点 ？</li>
</ol>
<p>左子树上处于“最左下”（没有左子树）的结点。</p>
<ol start="2">
<li>在中序线索化链表中结点的后继 ？</li>
</ol>
<p>若没有右子树，为后继线索所指结点。</p>
<p>否则为对其右子树进行中序遍历时访问的第一个结点；</p>
<h2 id="树与二叉树转换"><a href="#树与二叉树转换" class="headerlink" title="树与二叉树转换"></a>树与二叉树转换</h2><p>树的二叉链表表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CSNode&#123;</span><br><span class="line"></span><br><span class="line">   Elem     data;</span><br><span class="line"></span><br><span class="line">   struct CSNode *firstchild, *nextsibling;</span><br><span class="line"></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<h3 id="森林与二叉树"><a href="#森林与二叉树" class="headerlink" title="森林与二叉树"></a>森林与二叉树</h3><p>将树根看做兄弟</p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><table>
<thead>
<tr>
<th align="left">树</th>
<th align="left">二叉树</th>
<th>森林</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先序遍历</td>
<td align="left">先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td align="left">后序遍历</td>
<td align="left">中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><ol>
<li><p>第一棵树的根结点；</p>
</li>
<li><p>第一棵树的子树森林；</p>
</li>
<li><p>其它(除第一棵树外的)树构成的森林。</p>
</li>
</ol>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><p>权值低，深</p>
<p>找权值最低两个节点构造二叉树，root为权值和，直至没有独立节点</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>正则，没有deg=1的节点</li>
<li>$2n_0-1$个节点</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>霍夫曼编码，最短前缀编码</p>
<p>频率为权值，构造霍夫曼树</p>
<p>左路径为0，右路径为1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/Tree/" data-id="cklmi0hu10004bwucgocycq11" data-title="树与二叉树" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-graph" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/graph/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/graph/">图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="联通网的最小生成树"><a href="#联通网的最小生成树" class="headerlink" title="联通网的最小生成树"></a>联通网的最小生成树</h2><p>prim算法</p>
<p>与最小生成子树T与与其补集构成的割，选择最短跨边，连接的顶点加入T</p>
<h2 id="一个点到其他点最短路径"><a href="#一个点到其他点最短路径" class="headerlink" title="一个点到其他点最短路径"></a>一个点到其他点最短路径</h2><p>迪杰斯特拉算法</p>
<p>原点V0，选择与V0距离最短的点加入最短距离生成树</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>判断有向图是否存在回路</p>
<ol>
<li>从有向图中选取一个没有前驱的顶点，并输出之</li>
<li>从有向图中删去此顶点以及所有以它为尾的孤</li>
<li>重复上述两步，直至图空，或者图不空但找不到无<br> 前驱的顶点为止</li>
</ol>
<p>AOV</p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>节点VE，VL</p>
<p>边AE，AL</p>
<ol>
<li>求拓扑排序</li>
<li>按照拓扑排序求VE</li>
<li>拓扑排序逆序求VL</li>
<li>AE=弧头VE</li>
<li>AL=弧尾VL-弧Weight</li>
<li>AE=AL的弧即为关键路径</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/graph/" data-id="cklmi0hu20005bwuc18b2131a" data-title="图" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-external_sort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/external_sort/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/external_sort/">外部排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="外部排序定义"><a href="#外部排序定义" class="headerlink" title="外部排序定义"></a>外部排序定义</h2><p>归并次数<br>s等于归并树的高度,m为归并段数$s=log_2m$</p>
<p>t=内部排序所需时间+外存读写所需时间+内部归并所需时间</p>
<p>读写外存次数s+1</p>
<p>10个归并段，2路归并，再假设磁盘每个物理块可容纳200个记录，则每10000个记<br> 录需要50次读50次写，共100次操作。<br> 全部排序共需要读写次数为：d=100*(4+1)=500。</p>
<h2 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h2><p>k路归并，k个数中选最小</p>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>储存败者</p>
<p>ls[0]胜者</p>
<p>设ls[t]是b[s]的父节点<br> t=(s+k)/2</p>
<p>$s\in[0,m-1]归并段序号 $</p>
<p>$h=log_2k$</p>
<ol>
<li>调整（比赛过程）</li>
<li>创建，将ls[]节点初始化为KEY_MIN</li>
<li>从b[k-1]到b[0],插入，然后调整</li>
</ol>
<h2 id="置换选择排序构造初始归并段"><a href="#置换选择排序构造初始归并段" class="headerlink" title="置换选择排序构造初始归并段"></a>置换选择排序构造初始归并段</h2><p>原始文件&gt;&gt;内存（败者树）&gt;&gt;归并段（数据有序）</p>
<h3 id="败者树规则"><a href="#败者树规则" class="headerlink" title="败者树规则"></a>败者树规则</h3><p>从WA中所有比关键字 MIINMAX大的记录中，选择最小的记录，作为新的 MIINMAX,放入归并段，直至内存空或没有比MINMAX_NOW更大的数据，在归并段中加入标记，这样就完成了一个归并段。</p>
<p>先比段号，段号小的胜利</p>
<h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><p>带权路径和WPL最小，将较大节点放在靠近根节点处，k路归并</p>
<p>添加空归并段</p>
<p>虚段数u=k-1-(m-1)%(k-1) if (m-1)%(k-1)！=0</p>
<p>将k个最小值构成一个树，根为和</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/external_sort/" data-id="cklmi0hu30008bwuc4sd09jc0" data-title="外部排序" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/queue/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T01:56:07.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/queue/">队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>类似于线性表的顺序映象实现，指向表尾的指针可以作为栈顶指针。</p>
<ol>
<li>追加储存空间<br> <code>S.top = S.base + S.stacksize; //更新top指针</code><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><h2 id="进栈与上溢，出栈与下溢"><a href="#进栈与上溢，出栈与下溢" class="headerlink" title="进栈与上溢，出栈与下溢"></a>进栈与上溢，出栈与下溢</h2><h2 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h2></li>
</ol>
<h3 id="求解可能的序列数"><a href="#求解可能的序列数" class="headerlink" title="求解可能的序列数"></a>求解可能的序列数</h3><p>一般情形下，我们假设进栈序列为１，２，３，……，ｎ，可能的退栈序列有$f（ｎ）$种，对此，我们可以做如下推导：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当ｎ＝０时，ｍ（０）＝１：退栈序列为｛｝；</span><br><span class="line">当ｎ＝１时，ｍ（１）＝１：退栈序列为｛１｝；</span><br><span class="line">当ｎ＝２时，ｍ（２）＝２：</span><br><span class="line">退栈序列中１在首位，１左侧有０个数，１右侧有一个数，有ｍ（０）＊ｍ（１）种可能，１在末位，１左侧有一个数，右侧有０个数，有ｍ（１）＊ｍ（０）种，一共有ｍ（０）＊ｍ（１）＋ｍ（１）＊ｍ（０）种可能的序列。</span><br></pre></td></tr></table></figure>

<p>简单的推导中不难发现，将１置于ｉ＝１……ｎ的位置，则可能的序列数为$f（ｉ－１）\times f （ｎ－ｉ）$种。<br> 总结一下：<br> 一般的，设有n个元素序号按序号１,２，……，ｎ进栈，轮流让１在退栈序列的第１，第２，……，第ｎ位，则可能的的退栈序列种数为：<br> $f（０）\times f（ｎ－１）＋f（１）\times f（ｎ－２）＋……＋f（ｎ－１）\times f（０）<br> \＝\frac{1}{n+1}\timesＣ<em>{2n}^n<br> \＝\frac{（２ｎ）（２ｎ－１）……（ｎ＋２）}{ｎ！}$<br> 不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。<br> 反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。<br> 不合要求的2n位数与n＋1个0，n－1个1组成的排列一一对应。不符合要求方案数为$c</em>{2n}^{n+1}$</p>
<h3 id="不可能的退栈序列"><a href="#不可能的退栈序列" class="headerlink" title="不可能的退栈序列"></a>不可能的退栈序列</h3><p>设对于初始进栈序列1，2，3，……，ｎ，利用栈得到可能的退栈序列为ｐ１，ｐ２，……，ｐｉ，……，ｐｎ，</p>
<p>如果序号ｉ＜ｊ＜ｋ，且在进栈序列中ｐｉ＜ｐｊ＜ｐｋ，即：<br> ……，ｐｉ，……，ｐｊ，……，ｐｋ，……（ｐｉ＜ｐｊ＜ｐｋ）<br> 则……，ｐｋ，……，ｐｉ，……，ｐｊ，……就是不可能的退栈序列。</p>
<p>因为ｐｋ在ｐｉ和ｐｊ之后进栈，又先于ｐｉ和ｐｊ退栈，按照栈的后进先出的特性，ｐｉ压在ｐｊ的下面，理应ｐｊ先出，所以……，ｐｋ，……，ｐｉ，……，ｐｊ，……是不可能的。<br> 总结成一句话就是——当前下标大于后下标时，则后下标必定递减（或者说倒序）</p>
<p>不能先逆序再正序，即入栈序列为12345时，出栈序列54123不合法。</p>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ol>
<li><p>数制转换<br>初始化栈<br>InitStack(S);<br>依次计算当前的d进制数，并将其压栈<br>Push(S, N % 8); N = N/d;<br>依次从栈中取出计算的结果，并输出<br>Pop(S,e);<br>删除栈 DestroyStack(S); </p>
</li>
<li><p>括号匹配的检验</p>
<ol>
<li>凡出现左括弧，则进栈；</li>
<li>凡出现右括弧，首先检查栈是否空<br>若栈空，则表明该“右括弧”多余，<br>否则和栈顶元素比较，<br>若相匹配，则“左括弧出栈” ，<br>否则表明不匹配。</li>
<li>表达式检验结束时：<br>若栈空，则表明表达式中匹配正确；<br>否则表明“左括弧”有余。</li>
</ol>
</li>
<li><p>表达式求值</p>
<ol>
<li></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/queue/" data-id="cklmi0hu6000cbwucbszs55wh" data-title="队列" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cmake/" rel="tag">Cmake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cmake/" style="font-size: 10px;">Cmake</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/26/PKG_CONFIG/">PKG_CONFIG</a>
          </li>
        
          <li>
            <a href="/2021/02/26/%E5%AE%89%E8%A3%85OpenCvCpp%E5%BA%93/">安装OpenCvC++库</a>
          </li>
        
          <li>
            <a href="/2021/02/26/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/02/26/c++%E4%B8%8EOOP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/02/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>